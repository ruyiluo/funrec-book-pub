<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>3.3.3. 高阶特征交叉 &#8212; FunRec 推荐系统 0.0.1 documentation</title>

    <link rel="stylesheet" href="../../_static/material-design-lite-1.3.0/material.blue-deep_orange.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx_materialdesign_theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/fontawesome/all.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/fonts.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/d2l.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/d2l.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="3.3.4. 总结" href="3.summary.html" />
    <link rel="prev" title="3.3.2. 二阶特征交叉" href="1.second_order.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link" href="../index.html"><span class="section-number">3. </span>精排模型</a><i class="material-icons">navigate_next</i>
            <a class="mdl-navigation__link" href="index.html"><span class="section-number">3.3. </span>特征交叉</a><i class="material-icons">navigate_next</i>
            <a class="mdl-navigation__link is-active"><span class="section-number">3.3.3. </span>高阶特征交叉</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="../../search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
          <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="../../_sources/chapter_2_ranking/2.feature_crossing/2.higher_order.rst.txt" rel="nofollow">
  <i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../../index.html">
              <span class="title-text">
                  FunRec 推荐系统
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_preface/index.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_installation/index.html">安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_notation/index.html">符号</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../chapter_0_introduction/index.html">1. 推荐系统概述</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_0_introduction/0.intro.html">1.1. 推荐系统是什么？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_0_introduction/1.outline.html">1.2. 本书概览</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_1_retrieval/index.html">2. 召回模型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/index.html">2.1. 协同过滤</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/0.intro.html">2.1.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/1.usercf.html">2.1.2. 基于用户的协同过滤</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/2.itemcf.html">2.1.3. 基于物品的协同过滤</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/3.swing.html">2.1.4. Swing 算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/4.mf.html">2.1.5. 矩阵分解</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/5.summary.html">2.1.6. 总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/index.html">2.2. 向量召回</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/0.intro.html">2.2.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/1.i2i.html">2.2.2. i2i召回</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/2.u2i.html">2.2.3. u2i召回</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/3.summary.html">2.2.4. 总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/index.html">2.3. 序列召回</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/0.intro.html">2.3.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/1.user_interests.html">2.3.2. 深化用户兴趣表示</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/2.generateive_recall.html">2.3.3. 生成式召回方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/3.summary.html">2.3.4. 总结</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">3. 精排模型</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../0.intro.html">3.1. 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1.wide_and_deep.html">3.2. 记忆与泛化</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">3.3. 特征交叉</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="0.intro.html">3.3.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="1.second_order.html">3.3.2. 二阶特征交叉</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">3.3.3. 高阶特征交叉</a></li>
<li class="toctree-l3"><a class="reference internal" href="3.summary.html">3.3.4. 总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../3.sequence.html">3.4. 序列建模</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4.multi_objective/index.html">3.5. 多目标建模</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/1.intro.html">3.5.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/2.arch.html">3.5.2. 基础结构演进</a></li>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/3.dependency_modeling.html">3.5.3. 任务依赖建模</a></li>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/4.multi_loss_optim.html">3.5.4. 多目标损失融合</a></li>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/5.summary.html">3.5.5. 小结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../5.multi_scenario/index.html">3.6. 多场景建模</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../5.multi_scenario/1.intro.html">3.6.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../5.multi_scenario/2.multi_tower.html">3.6.2. 多塔结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../5.multi_scenario/3.dynamic_weight.html">3.6.3. 动态权重建模</a></li>
<li class="toctree-l3"><a class="reference internal" href="../5.multi_scenario/4.summary.html">3.6.4. 小结</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_3_rerank/index.html">4. 重排模型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_3_rerank/1.intro.html">4.1. 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_3_rerank/2.greedy.html">4.2. 基于贪心的重排</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_3_rerank/3.personalized.html">4.3. 基于个性化的重排</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_3_rerank/4.summary.html">4.4. 本章小结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_4_trends/index.html">5. 难点及热点研究</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/0.intro.html">5.1. 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/1.debias.html">5.2. 模型去偏</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/2.cold_start.html">5.3. 冷启动问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/2.cold_start.html#id2">5.4. 内容冷启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/2.cold_start.html#id5">5.5. 用户冷启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/3.generative.html">5.6. 生成式推荐</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/4.summary.html">5.7. 本章小结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_5_projects/index.html">6. 安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_appendix/index.html">7. Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_appendix/word2vec.html">7.1. Word2vec</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_references/references.html">参考文献</a></li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">

	<script type="text/javascript" src="../../_static/sphinx_materialdesign_theme.js "></script>
    <header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../../index.html">
              <span class="title-text">
                  FunRec 推荐系统
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_preface/index.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_installation/index.html">安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_notation/index.html">符号</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../chapter_0_introduction/index.html">1. 推荐系统概述</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_0_introduction/0.intro.html">1.1. 推荐系统是什么？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_0_introduction/1.outline.html">1.2. 本书概览</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_1_retrieval/index.html">2. 召回模型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/index.html">2.1. 协同过滤</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/0.intro.html">2.1.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/1.usercf.html">2.1.2. 基于用户的协同过滤</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/2.itemcf.html">2.1.3. 基于物品的协同过滤</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/3.swing.html">2.1.4. Swing 算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/4.mf.html">2.1.5. 矩阵分解</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/1.cf/5.summary.html">2.1.6. 总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/index.html">2.2. 向量召回</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/0.intro.html">2.2.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/1.i2i.html">2.2.2. i2i召回</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/2.u2i.html">2.2.3. u2i召回</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/2.embedding/3.summary.html">2.2.4. 总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/index.html">2.3. 序列召回</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/0.intro.html">2.3.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/1.user_interests.html">2.3.2. 深化用户兴趣表示</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/2.generateive_recall.html">2.3.3. 生成式召回方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../chapter_1_retrieval/3.sequence/3.summary.html">2.3.4. 总结</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">3. 精排模型</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../0.intro.html">3.1. 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1.wide_and_deep.html">3.2. 记忆与泛化</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">3.3. 特征交叉</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="0.intro.html">3.3.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="1.second_order.html">3.3.2. 二阶特征交叉</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">3.3.3. 高阶特征交叉</a></li>
<li class="toctree-l3"><a class="reference internal" href="3.summary.html">3.3.4. 总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../3.sequence.html">3.4. 序列建模</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4.multi_objective/index.html">3.5. 多目标建模</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/1.intro.html">3.5.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/2.arch.html">3.5.2. 基础结构演进</a></li>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/3.dependency_modeling.html">3.5.3. 任务依赖建模</a></li>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/4.multi_loss_optim.html">3.5.4. 多目标损失融合</a></li>
<li class="toctree-l3"><a class="reference internal" href="../4.multi_objective/5.summary.html">3.5.5. 小结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../5.multi_scenario/index.html">3.6. 多场景建模</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../5.multi_scenario/1.intro.html">3.6.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../5.multi_scenario/2.multi_tower.html">3.6.2. 多塔结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../5.multi_scenario/3.dynamic_weight.html">3.6.3. 动态权重建模</a></li>
<li class="toctree-l3"><a class="reference internal" href="../5.multi_scenario/4.summary.html">3.6.4. 小结</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_3_rerank/index.html">4. 重排模型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_3_rerank/1.intro.html">4.1. 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_3_rerank/2.greedy.html">4.2. 基于贪心的重排</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_3_rerank/3.personalized.html">4.3. 基于个性化的重排</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_3_rerank/4.summary.html">4.4. 本章小结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_4_trends/index.html">5. 难点及热点研究</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/0.intro.html">5.1. 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/1.debias.html">5.2. 模型去偏</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/2.cold_start.html">5.3. 冷启动问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/2.cold_start.html#id2">5.4. 内容冷启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/2.cold_start.html#id5">5.5. 用户冷启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/3.generative.html">5.6. 生成式推荐</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_4_trends/4.summary.html">5.7. 本章小结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_5_projects/index.html">6. 安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_appendix/index.html">7. Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter_appendix/word2vec.html">7.1. Word2vec</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../chapter_references/references.html">参考文献</a></li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content" role="main">
        
  <section id="higher-order-feature-crossing">
<span id="id1"></span><h1><span class="section-number">3.3.3. </span>高阶特征交叉<a class="headerlink" href="#higher-order-feature-crossing" title="Permalink to this heading">¶</a></h1>
<p>在掌握了二阶特征交叉的各种技术后，我们发现这些模型虽然能够显式地处理二阶交互，但对于更高阶的特征组合，它们主要依赖于深度神经网络（DNN）部分来隐式学习。然而，这种“隐式”学习的过程如同一个黑盒，我们很难解释模型具体学习到了哪些特征的组合，以及这些组合是如何影响最终预测的。因此，研究者们开始探索能否设计出像FM处理二阶交叉一样，能够<strong>显式地、可控地捕捉高阶交叉</strong>的网络结构，从而在提升模型性能的同时，增强模型的可解释性。</p>
<section id="id2">
<h2><span class="section-number">3.3.3.1. </span>残差连接的高阶交叉<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>为了解决上述问题，Deep &amp; Cross Network (DCN) <span id="id3">(<a class="reference internal" href="../../chapter_references/references.html#id43" title="Wang, R., Fu, B., Fu, G., &amp; Wang, M. (2017). Deep &amp; cross network for ad click predictions. Proceedings of the ADKDD'17 (pp. 1–7).">Wang <em>et al.</em>, 2017</a>)</span>
通过一个创新的Cross Network来替代Wide &amp;
Deep模型中的Wide部分。该网络的核心思想是在每一层都与原始的输入特征进行交叉，从而以一种显式且可控的方式，自动构建更高阶的特征交互，而无需繁琐的人工特征工程。</p>
<figure class="align-default" id="id11">
<img alt="../../_images/deepcross.png" src="../../_images/deepcross.png" />
<figcaption>
<p><span class="caption-number">图3.3.7 </span><span class="caption-text">DCN模型结构</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>DCN的整体结构由并行的Cross Network和Deep
Network两部分组成，它们共享相同的Embedding层输入。首先，模型将稀疏的类别特征转换为低维稠密的Embedding向量，并与数值型特征拼接在一起，形成统一的输入向量
<span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span>。</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-0">
<span class="eqno">(3.3.27)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-0" title="Permalink to this equation">¶</a></span>\[\mathbf{x}_0 = [\mathbf{x}_{\text{embed}, 1}^T, \ldots, \mathbf{x}_{\text{embed}, k}^T, \mathbf{x}_{\text{dense}}^T]\]</div>
<p>这个初始向量 <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> 会被同时送入Cross Network和Deep
Network。</p>
<p>Cross
Network是DCN的核心创新。它由多个交叉层堆叠而成，其精妙之处在于每一层的计算都保留了与原始输入
<span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> 的直接交互。第 <span class="math notranslate nohighlight">\(l+1\)</span> 层的计算公式如下：</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-1">
<span class="eqno">(3.3.28)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-1" title="Permalink to this equation">¶</a></span>\[\mathbf{x}_{l+1} = \mathbf{x}_0 \mathbf{x}_l^T \mathbf{w}_l + \mathbf{b}_l + \mathbf{x}_l\]</div>
<p>其中<span class="math notranslate nohighlight">\(\mathbf{x}_l, \mathbf{x}_{l+1} \in \mathbb{R}^d\)</span> 分别是第
<span class="math notranslate nohighlight">\(l\)</span> 层和第 <span class="math notranslate nohighlight">\(l+1\)</span>
层的输出列向量，<span class="math notranslate nohighlight">\(\mathbf{x}_0 \in \mathbb{R}^d\)</span> 是Cross
Network的初始输入向量，<span class="math notranslate nohighlight">\(\mathbf{w}_l, \mathbf{b}_l \in \mathbb{R}^d\)</span>
分别是第 <span class="math notranslate nohighlight">\(l\)</span> 层的权重和偏置列向量。</p>
<figure class="align-default" id="id12">
<img alt="../../_images/cross_network.png" src="../../_images/cross_network.png" />
<figcaption>
<p><span class="caption-number">图3.3.8 </span><span class="caption-text">Cross Network</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>我们可以观察到，这个结构本质上是一个残差网络。每一层都在上一层输出
<span class="math notranslate nohighlight">\(\mathbf{x}_l\)</span> 的基础上，增加了一个交叉项
<span class="math notranslate nohighlight">\(\mathbf{x}_0 \mathbf{x}_l^T \mathbf{w}_l\)</span> 和一个偏置项
<span class="math notranslate nohighlight">\(\mathbf{b}_l\)</span>。这个交叉项非常关键，它让原始输入
<span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> 与当前层的输入 <span class="math notranslate nohighlight">\(\mathbf{x}_l\)</span>
进行了显式的特征交叉。随着层数的加深，<strong>特征交叉的阶数也随之增加</strong>。例如，在第一层（<span class="math notranslate nohighlight">\(l=0\)</span>），<span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span>
包含了与 <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span>
相关的二阶交叉项；在第二层（<span class="math notranslate nohighlight">\(l=1\)</span>），由于 <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span>
已经包含了二阶信息，它与 <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span>
的再次交叉就会产生三阶的交叉项。因此，Cross
Network的深度决定了它能显式捕获的最高特征交叉阶数。这种设计使得参数量只随着输入维度呈线性增长，非常高效。</p>
<p>与Cross Network并行的Deep
Network部分是一个标准的全连接神经网络，用于隐式地学习高阶非线性关系，其结构与我们熟悉的DeepFM中的DNN部分类似。最后，模型将Cross
Network的输出 <span class="math notranslate nohighlight">\(\mathbf{x}_{L_1}\)</span> 和Deep Network的输出
<span class="math notranslate nohighlight">\(\mathbf{h}_{L_2}\)</span>
拼接起来，通过一个逻辑回归层得到最终的预测概率。</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-2">
<span class="eqno">(3.3.29)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-2" title="Permalink to this equation">¶</a></span>\[\mathbf{p} = \sigma([\mathbf{x}_{L_1}^T, \mathbf{h}_{L_2}^T] \mathbf{w}_{\text{logits}})\]</div>
<p>DCN通过Cross
Network提供了一种有效且高效的显式高阶特征交叉方案，并结合DNN的隐式交叉能力，为推荐模型的设计提供了新的思路。</p>
</section>
<section id="id4">
<h2><span class="section-number">3.3.3.2. </span>向量级别的特征交互<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>尽管DCN能够显式地构建高阶特征，但它的交叉方式是在 <strong>元素级别(bit-wise)</strong>
上进行的。这意味着Embedding向量中的每一个元素都会独立地与其他特征的Embedding元素进行交互，这在一定程度上忽略了Embedding向量作为一个整体所代表的特征场的概念。为了解决这个问题，xDeepFM模型被提了出来，其核心是设计了一个全新的压缩交互网络（Compressed
Interaction Network, CIN） <span id="id5">(<a class="reference internal" href="../../chapter_references/references.html#id51" title="Lian, J., Zhou, X., Zhang, F., Chen, Z., Xie, X., &amp; Sun, G. (2018). Xdeepfm: combining explicit and implicit feature interactions for recommender systems. Proceedings of the 24th ACM SIGKDD international conference on knowledge discovery &amp; data mining (pp. 1754–1763).">Lian <em>et al.</em>, 2018</a>)</span> ，以
<strong>向量级别(vector-wise)</strong>
的方式进行特征交互，这更符合我们进行特征工程时的直觉。</p>
<p>xDeepFM的整体架构同样由三部分组成：一个传统的线性部分、一个用于隐式高阶交叉的DNN，以及创新的CIN网络用于显式高阶交叉。这三部分的输出最终被结合起来进行预测。</p>
<figure class="align-default" id="id13">
<img alt="../../_images/xdeepfm.png" src="../../_images/xdeepfm.png" />
<figcaption>
<p><span class="caption-number">图3.3.9 </span><span class="caption-text">xdeepfm模型架构</span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>CIN的设计目标是实现向量级别的显式高阶交互，同时控制网络复杂度。它的输入是一个<span class="math notranslate nohighlight">\(m \times D\)</span>的矩阵
<span class="math notranslate nohighlight">\(\mathbf{X}_0\)</span>，其中 <span class="math notranslate nohighlight">\(m\)</span>
是特征域（Field）的数量，<span class="math notranslate nohighlight">\(D\)</span> 是Embedding的维度，矩阵的第
<span class="math notranslate nohighlight">\(i\)</span> 行就是第 <span class="math notranslate nohighlight">\(i\)</span> 个特征域的Embedding向量
<span class="math notranslate nohighlight">\(\mathbf{e}_i\)</span>。</p>
<p>CIN的计算过程在每一层都分为两步。在计算第 <span class="math notranslate nohighlight">\(k\)</span> 层的输出
<span class="math notranslate nohighlight">\(\mathbf{X}_k\)</span> 时，它依赖于上一层的输出 <span class="math notranslate nohighlight">\(\mathbf{X}_{k-1}\)</span>
和最原始的输入 <span class="math notranslate nohighlight">\(\mathbf{X}_0\)</span>。</p>
<p>第一步，模型计算出上一层输出的 <span class="math notranslate nohighlight">\(H_{k-1}\)</span> 个向量与原始输入层的
<span class="math notranslate nohighlight">\(m\)</span>
个向量之间的所有成对交互，生成一个中间结果。具体来说，是通过哈达玛积（Hadamard
product）<span class="math notranslate nohighlight">\(\circ\)</span> 来实现的。这个操作会产生
<span class="math notranslate nohighlight">\(H_{k-1} \times m\)</span> 个交互向量，每个向量的维度仍然是 <span class="math notranslate nohighlight">\(D\)</span>。</p>
<p>第二步，为了生成第 <span class="math notranslate nohighlight">\(k\)</span> 层的第 <span class="math notranslate nohighlight">\(h\)</span> 个新特征向量
<span class="math notranslate nohighlight">\(\mathbf{X}_{h,*}^k\)</span>，模型对上一步产生的所有交互向量进行加权求和。这个过程可以看作是对所有潜在的交叉特征进行一次“压缩”或“提炼”。</p>
<p>综合起来，其核心计算公式如下：</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-3">
<span class="eqno">(3.3.30)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-3" title="Permalink to this equation">¶</a></span>\[\mathbf{X}_{h,*}^k = \sum_{i=1}^{H_{k-1}} \sum_{j=1}^{m} \mathbf{W}_{i,j}^{k,h} (\mathbf{X}_{i,*}^{k-1} \circ \mathbf{X}_{j,*}^0)\]</div>
<p>其中：</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X}_k \in \mathbb{R}^{H_k \times D}\)</span> 是CIN第 <span class="math notranslate nohighlight">\(k\)</span>
层的输出，可以看作是一个包含了 <span class="math notranslate nohighlight">\(H_k\)</span>
个特征向量的集合，称为“特征图”。<span class="math notranslate nohighlight">\(H_k\)</span> 是第 <span class="math notranslate nohighlight">\(k\)</span>
层特征图的数量。</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{X}_{i,*}^{k-1}\)</span> 是第 <span class="math notranslate nohighlight">\(k-1\)</span> 层输出的第 <span class="math notranslate nohighlight">\(i\)</span>
个 <span class="math notranslate nohighlight">\(D\)</span> 维向量。</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{X}_{j,*}^0\)</span> 是原始输入矩阵的第 <span class="math notranslate nohighlight">\(j\)</span> 个 <span class="math notranslate nohighlight">\(D\)</span>
维向量（即第 <span class="math notranslate nohighlight">\(j\)</span> 个特征域的Embedding）。</p></li>
<li><p><span class="math notranslate nohighlight">\(\circ\)</span> 是哈达玛积，它实现了<strong>向量级别的交互</strong>，保留了
<span class="math notranslate nohighlight">\(D\)</span> 维的向量结构。</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}_{k,h} \in \mathbb{R}^{H_{k-1} \times m}\)</span>
是一个参数矩阵。它为每一个由
<span class="math notranslate nohighlight">\((\mathbf{X}_{i,*}^{k-1}, \mathbf{X}_{j,*}^0)\)</span>
产生的交互向量都提供了一个权重，通过加权求和的方式，将
<span class="math notranslate nohighlight">\(H_{k-1} \times m\)</span> 个交互向量的信息“压缩”成一个全新的 <span class="math notranslate nohighlight">\(D\)</span>
维向量 <span class="math notranslate nohighlight">\(\mathbf{X}_{h,*}^k\)</span>。</p></li>
</ul>
<p>这个过程清晰地展示了特征交互是如何在向量级别上逐层发生的。第 <span class="math notranslate nohighlight">\(k\)</span>
层的输出 <span class="math notranslate nohighlight">\(\mathbf{X}_k\)</span> 包含了所有 <span class="math notranslate nohighlight">\(k+1\)</span> 阶的特征交互信息。</p>
<p>在计算出每一层（从第<span class="math notranslate nohighlight">\(1\)</span>层到第<span class="math notranslate nohighlight">\(T\)</span>层）的特征图
<span class="math notranslate nohighlight">\(\mathbf{X}_k\)</span> 后，CIN会对每个特征图 <span class="math notranslate nohighlight">\(\mathbf{X}_k\)</span>
的所有向量（<span class="math notranslate nohighlight">\(H_k\)</span>个）在维度 <span class="math notranslate nohighlight">\(D\)</span> 上进行求和池化（Sum
Pooling），得到一个池化后的向量
<span class="math notranslate nohighlight">\(\mathbf{p}_k \in \mathbb{R}^{H_k}\)</span>。最后，将所有层的池化向量拼接起来，形成CIN部分的最终输出。</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-4">
<span class="eqno">(3.3.31)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-4" title="Permalink to this equation">¶</a></span>\[\mathbf{p}^+ = [\mathbf{p}_1, \mathbf{p}_2, \ldots, \mathbf{p}_T]\]</div>
<p>这个输出 <span class="math notranslate nohighlight">\(\mathbf{p}^+\)</span> 捕获了从二阶到 <span class="math notranslate nohighlight">\(T+1\)</span>
阶的所有显式、向量级别的交叉特征信息。最终，xDeepFM将线性部分、DNN部分和CIN部分的输出结合起来，通过一个Sigmoid函数得到最终的预测结果。</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-5">
<span class="eqno">(3.3.32)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-5" title="Permalink to this equation">¶</a></span>\[\hat{y} = \sigma(\mathbf{w}_{\text{linear}}^T \mathbf{a} + \mathbf{w}_{\text{dnn}}^T \mathbf{x}_{\text{dnn}}^k + \mathbf{w}_{\text{cin}}^T \mathbf{p}^+ + \mathbf{b})\]</div>
<p>其中<span class="math notranslate nohighlight">\(\mathbf{a}\)</span>
表示原始特征，<span class="math notranslate nohighlight">\(\mathbf{x}_{\text{dnn}}^k\)</span>
表示DNN的输出，<span class="math notranslate nohighlight">\(\mathbf{b}\)</span> 是可学习参数。</p>
<p>通过引入CIN，<strong>xDeepFM成功地将显性的、向量级别的特征交互与隐性的、元素级别的特征交互结合在同一个模型中</strong>，为自动学习高阶特征交互提供了又一个强大且更具解释性的解决方案。</p>
</section>
<section id="id6">
<h2><span class="section-number">3.3.3.3. </span>自注意力的自适应交互<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<p>DCN通过残差连接实现了元素级别的高阶交互，xDeepFM通过CIN网络实现了向量级别的高阶交互，但这两种方法都有一个共同的局限性：它们对高阶特征交互的构建方式是相对固定的。DCN的每一层都必须与原始输入进行交叉，而xDeepFM的CIN网络则按照预定义的方式进行向量交互。那么，<strong>能否设计一种更加灵活、智能的高阶特征交互机制，让模型自主地决定哪些特征应该参与交互，以及交互的强度如何？</strong></p>
<p>AutoInt (Automatic Feature Interaction) <span id="id7">(<a class="reference internal" href="../../chapter_references/references.html#id44" title="Song, W., Shi, C., Xiao, Z., Duan, Z., Xu, Y., Zhang, M., &amp; Tang, J. (2019). Autoint: automatic feature interaction learning via self-attentive neural networks. Proceedings of the 28th ACM international conference on information and knowledge management (pp. 1161–1170).">Song <em>et al.</em>, 2019</a>)</span>
模型回答了这个问题。它借鉴了自然语言处理领域中 Transformer
架构的核心思想，<strong>通过多头自注意力机制来自动、自适应地学习任意阶数的特征交互</strong>。与前面介绍的方法不同，AutoInt
不依赖于固定的交互模式，而是让模型在训练过程中学习出最有效的特征交互组合。</p>
<figure class="align-default" id="id14">
<img alt="../../_images/autoint_overview.png" src="../../_images/autoint_overview.png" />
<figcaption>
<p><span class="caption-number">图3.3.10 </span><span class="caption-text">AutoInt模型原理示意图</span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>AutoInt
的整体架构相对简洁，它将所有输入特征（无论是类别型还是数值型）都转换为相同维度的嵌入向量
<span class="math notranslate nohighlight">\(\mathbf{e}_m \in \mathbb{R}^d\)</span>，其中 <span class="math notranslate nohighlight">\(m\)</span> 代表第 <span class="math notranslate nohighlight">\(m\)</span>
个特征域。这些嵌入向量构成了自注意力网络的输入，类似于 Transformer 中的
token embeddings。</p>
<section id="id8">
<h3><span class="section-number">3.3.3.3.1. </span>多头自注意力机制<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<p>AutoInt
的核心是其交互层，该层由多头自注意力机制构成。对于任意两个特征的嵌入向量
<span class="math notranslate nohighlight">\(\mathbf{e}_m\)</span> 和
<span class="math notranslate nohighlight">\(\mathbf{e}_k\)</span>，自注意力机制会计算它们之间的相关性得分。这个过程在每个“注意力头”
(head) <span class="math notranslate nohighlight">\(h\)</span> 中独立进行。具体来说，对于特征 <span class="math notranslate nohighlight">\(m\)</span> 和特征
<span class="math notranslate nohighlight">\(k\)</span>，它们在第 <span class="math notranslate nohighlight">\(h\)</span> 个注意力头中的相关性得分
<span class="math notranslate nohighlight">\(\alpha_{m,k}^{(h)}\)</span> 计算如下：</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-6">
<span class="eqno">(3.3.33)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-6" title="Permalink to this equation">¶</a></span>\[\alpha_{m,k}^{(h)} = \frac{\exp(\psi^{(h)}(\mathbf{e}_m, \mathbf{e}_k))}{\sum_{l=1}^{M}\exp(\psi^{(h)}(\mathbf{e}_m, \mathbf{e}_l))}\]</div>
<p>这里的 <span class="math notranslate nohighlight">\(M\)</span> 是特征域的总数，而
<span class="math notranslate nohighlight">\(\psi^{(h)}(\mathbf{e}_m, \mathbf{e}_k)\)</span>
是一个用于衡量两个嵌入向量相似度的函数，通常是缩放点积注意力：</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-7">
<span class="eqno">(3.3.34)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-7" title="Permalink to this equation">¶</a></span>\[\psi^{(h)}\left(\mathbf{e}_{\mathbf{m}}, \mathbf{e}_{\mathbf{k}}\right)=\left\langle\mathbf{W}_{\text {Query }}^{(h)} \mathbf{e}_{\mathbf{m}}, \mathbf{W}_{\text {Key }}^{(h)} \mathbf{e}_{\mathbf{k}}\right\rangle\]</div>
<p>其中
<span class="math notranslate nohighlight">\(\mathbf{W}_{\text{Query}}^{(h)} \in \mathbb{R}^{d' \times d}\)</span> 和
<span class="math notranslate nohighlight">\(\mathbf{W}_{\text{Key}}^{(h)} \in \mathbb{R}^{d' \times d}\)</span>
是可学习的投影矩阵，它们分别将原始嵌入向量映射到“查询”（Query）和“键”（Key）空间。<span class="math notranslate nohighlight">\(d'\)</span>
是投影后的维度。</p>
<p>在计算出所有特征对之间的相关性得分后，模型会利用这些得分来对所有特征的“值”（Value）向量进行加权求和，从而为特征
<span class="math notranslate nohighlight">\(\mathbf{e}_m\)</span> 生成一个新的、融合了其他特征信息的表示
<span class="math notranslate nohighlight">\(\mathbf{\tilde{e}}_m^{(h)}\)</span>：</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-8">
<span class="eqno">(3.3.35)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-8" title="Permalink to this equation">¶</a></span>\[\mathbf{\tilde{e}}_m^{(h)} = \sum_{k=1}^{M} \alpha_{m,k}^{(h)} (\mathbf{W}_{\text{Value}}^{(h)} \mathbf{e}_k)\]</div>
<p>其中
<span class="math notranslate nohighlight">\(\mathbf{W}_{\text{Value}}^{(h)} \in \mathbb{R}^{d' \times d}\)</span>
同样是一个可学习的投影矩阵。这个新的表示
<span class="math notranslate nohighlight">\(\mathbf{\tilde{e}}_m^{(h)}\)</span>
本质上就是一个通过自适应学习得到的新组合特征。</p>
<figure class="align-default" id="id15">
<img alt="../../_images/autoint_attention.png" src="../../_images/autoint_attention.png" />
<figcaption>
<p><span class="caption-number">图3.3.11 </span><span class="caption-text">自注意力机制示意图</span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="id9">
<h3><span class="section-number">3.3.3.3.2. </span>多层交互与高阶特征学习<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h3>
<p>“多头”机制允许模型在不同的子空间中并行地学习不同方面的特征交互。模型将所有
<span class="math notranslate nohighlight">\(H\)</span> 个头的输出拼接起来，形成一个更丰富的特征表示：</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-9">
<span class="eqno">(3.3.36)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-9" title="Permalink to this equation">¶</a></span>\[\mathbf{\tilde{e}}_m = \mathbf{\tilde{e}}_m^{(1)} \oplus \mathbf{\tilde{e}}_m^{(2)} \oplus \cdots \oplus \mathbf{\tilde{e}}_m^{(H)}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\oplus\)</span>
表示拼接操作。为了保留原始信息并稳定训练过程，AutoInt
还引入了残差连接（Residual
Connection），将新生成的交互特征与原始特征相结合：</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-10">
<span class="eqno">(3.3.37)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-10" title="Permalink to this equation">¶</a></span>\[\mathbf{e}_m^{\text{Res}}= \text{ReLU}(\mathbf{e}_m + \mathbf{W}_{\text{Res}} \mathbf{\tilde{e}}_m)\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{W}_{\text{Res}}\)</span> 是一个用于匹配维度的投影矩阵。</p>
<p><strong>AutoInt
的关键创新在于其高阶特征交互的构建方式</strong>。通过堆叠多个这样的交互层，AutoInt
能够显式地构建任意高阶的特征交互。第一层的输出包含了二阶交互信息，第二层的输出则包含了三阶交互信息，以此类推。每一层的输出都代表了更高一阶的、自适应学习到的特征组合。与
DCN 和 xDeepFM 不同，AutoInt
中的高阶交互不是通过固定的数学公式构建的，而是通过注意力权重动态决定的，这使得模型能够学习到更加灵活和有效的特征交互模式。</p>
<p>最终，所有层输出的特征表示被拼接在一起，送入一个简单的逻辑回归层进行最终的点击率预测：</p>
<div class="math notranslate nohighlight" id="equation-chapter-2-ranking-2-feature-crossing-2-higher-order-11">
<span class="eqno">(3.3.38)<a class="headerlink" href="#equation-chapter-2-ranking-2-feature-crossing-2-higher-order-11" title="Permalink to this equation">¶</a></span>\[\hat{y}=\sigma\left(\mathbf{w}^{\mathrm{T}}\left(\mathbf{e}_{1}^{\mathbf{Res}} \oplus \mathbf{e}_{2}^{\mathbf{Res}} \oplus \cdots \oplus \mathbf{e}_{\mathbf{M}}^{\text {Res}}\right)+b\right)\]</div>
<p>AutoInt 的一个巨大优势是其可解释性，通过可视化注意力权重矩阵
<span class="math notranslate nohighlight">\(\alpha^{(h)}\)</span>，我们可以直观地看到模型认为哪些特征组合是最重要的。这种基于自注意力机制的高阶特征交互不仅提升了模型的表达能力，还为高阶特征交互的学习提供了一个全新的、更加灵活的范式。</p>
</section>
</section>
<section id="id10">
<h2><span class="section-number">3.3.3.4. </span>代码实践<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;../../&#39;</span><span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">funrec</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">funrec.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">compare_models</span>

<span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;dcn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;xdeepfm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;autoint&#39;</span>
<span class="p">]</span>

<span class="n">results</span><span class="p">,</span> <span class="n">table</span> <span class="o">=</span> <span class="n">compare_models</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">config_dir</span><span class="o">=</span><span class="s1">&#39;../../funrec/config/&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
<div class="output highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---------+--------+--------+---------------+</span>
<span class="o">|</span> <span class="n">Model</span>   <span class="o">|</span>    <span class="n">auc</span> <span class="o">|</span>   <span class="n">gauc</span> <span class="o">|</span>   <span class="n">valid_users</span> <span class="o">|</span>
<span class="o">+=========+========+========+===============+</span>
<span class="o">|</span> <span class="n">dcn</span>     <span class="o">|</span> <span class="mf">0.603</span>  <span class="o">|</span> <span class="mf">0.5745</span> <span class="o">|</span>           <span class="mi">928</span> <span class="o">|</span>
<span class="o">+---------+--------+--------+---------------+</span>
<span class="o">|</span> <span class="n">xdeepfm</span> <span class="o">|</span> <span class="mf">0.6021</span> <span class="o">|</span> <span class="mf">0.575</span>  <span class="o">|</span>           <span class="mi">928</span> <span class="o">|</span>
<span class="o">+---------+--------+--------+---------------+</span>
<span class="o">|</span> <span class="n">autoint</span> <span class="o">|</span> <span class="mf">0.6174</span> <span class="o">|</span> <span class="mf">0.5709</span> <span class="o">|</span>           <span class="mi">928</span> <span class="o">|</span>
<span class="o">+---------+--------+--------+---------------+</span>
</pre></div>
</div>
</section>
</section>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">3.3.3. 高阶特征交叉</a><ul>
<li><a class="reference internal" href="#id2">3.3.3.1. 残差连接的高阶交叉</a></li>
<li><a class="reference internal" href="#id4">3.3.3.2. 向量级别的特征交互</a></li>
<li><a class="reference internal" href="#id6">3.3.3.3. 自注意力的自适应交互</a><ul>
<li><a class="reference internal" href="#id8">3.3.3.3.1. 多头自注意力机制</a></li>
<li><a class="reference internal" href="#id9">3.3.3.3.2. 多层交互与高阶特征学习</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">3.3.3.4. 代码实践</a></li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="1.second_order.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L fas fa-arrow-left fa-lg"></i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>3.3.2. 二阶特征交叉</div>
         </div>
     </a>
     <a id="button-next" href="3.summary.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
         <i class="pagenation-arrow-R fas fa-arrow-right fa-lg"></i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>3.3.4. 总结</div>
        </div>
     </a>
  </div>
        
        </main>
    </div>
  </body>
</html>